package serve_test

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"testing"
	"time"

	"github.com/organic-programming/go-holons/pkg/grpcclient"
	"github.com/organic-programming/go-holons/pkg/serve"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	testgrpc "google.golang.org/grpc/interop/grpc_testing"
	"google.golang.org/grpc/metadata"
	reflectionv1alpha "google.golang.org/grpc/reflection/grpc_reflection_v1alpha"
	"google.golang.org/grpc/status"
)

type serveEchoServer struct {
	testgrpc.UnimplementedTestServiceServer
}

func (s *serveEchoServer) EmptyCall(context.Context, *testgrpc.Empty) (*testgrpc.Empty, error) {
	return &testgrpc.Empty{}, nil
}

func (s *serveEchoServer) UnaryCall(ctx context.Context, in *testgrpc.SimpleRequest) (*testgrpc.SimpleResponse, error) {
	payload := in.GetPayload()
	if payload == nil {
		payload = &testgrpc.Payload{Type: testgrpc.PayloadType_COMPRESSABLE, Body: []byte("echo")}
	}

	_ = grpc.SetHeader(ctx, metadata.Pairs("x-holon", "go-holons"))
	_ = grpc.SetTrailer(ctx, metadata.Pairs("x-holon-trailer", "done"))

	if delay := parseSleepMillis(payload.GetBody()); delay > 0 {
		timer := time.NewTimer(delay)
		defer timer.Stop()
		select {
		case <-timer.C:
		case <-ctx.Done():
			return nil, ctx.Err()
		}
	}

	return &testgrpc.SimpleResponse{
		Payload: &testgrpc.Payload{
			Type: payload.GetType(),
			Body: append([]byte(nil), payload.GetBody()...),
		},
	}, nil
}

func (s *serveEchoServer) FullDuplexCall(stream testgrpc.TestService_FullDuplexCallServer) error {
	for {
		req, err := stream.Recv()
		if errors.Is(err, io.EOF) {
			return nil
		}
		if err != nil {
			return err
		}
		payload := req.GetPayload()
		if payload == nil {
			payload = &testgrpc.Payload{Type: testgrpc.PayloadType_COMPRESSABLE, Body: []byte{}}
		}
		if err := stream.Send(&testgrpc.StreamingOutputCallResponse{
			Payload: &testgrpc.Payload{
				Type: payload.GetType(),
				Body: append([]byte(nil), payload.GetBody()...),
			},
		}); err != nil {
			return err
		}
	}
}

func TestServeHelperProcess(t *testing.T) {
	if os.Getenv("GO_WANT_SERVE_HELPER") != "1" {
		t.Skip("serve helper process")
	}

	helperArgs := helperProcessArgs(os.Args)
	if len(helperArgs) < 3 {
		fmt.Fprintf(os.Stderr, "serve helper expects: <mode> <listen-uri> <reflect>\n")
		os.Exit(2)
	}

	mode := helperArgs[0]
	listenURI := helperArgs[1]
	reflectEnabled, err := strconv.ParseBool(helperArgs[2])
	if err != nil {
		fmt.Fprintf(os.Stderr, "invalid reflect value %q: %v\n", helperArgs[2], err)
		os.Exit(2)
	}

	register := func(s *grpc.Server) {
		testgrpc.RegisterTestServiceServer(s, &serveEchoServer{})
	}

	switch mode {
	case "run":
		err = serve.Run(listenURI, register)
	case "run-with-options":
		err = serve.RunWithOptions(listenURI, register, reflectEnabled)
	default:
		fmt.Fprintf(os.Stderr, "unknown helper mode %q\n", mode)
		os.Exit(2)
	}

	if err != nil && !errors.Is(err, grpc.ErrServerStopped) {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(3)
	}
	os.Exit(0)
}

func TestRunServesGRPCOnRandomPort(t *testing.T) {
	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
	address := fmt.Sprintf("127.0.0.1:%d", port)

	cmd, logs := startServeProcess(t, "run", listenURI, true)
	defer stopServeProcess(t, cmd, logs)

	conn := dialServeAndWait(t, address)
	defer conn.Close()

	requireUnaryEchoEventually(t, conn, "serve-run")
	requireStreamEchoEventually(t, conn, []string{"serve-stream-1", "serve-stream-2"})
}

func TestRunServesGRPCOnUnixSocket(t *testing.T) {
	socketPath := filepath.Join(os.TempDir(), fmt.Sprintf("serve-%d.sock", time.Now().UnixNano()))
	t.Cleanup(func() { _ = os.Remove(socketPath) })

	listenURI := "unix://" + socketPath
	cmd, logs := startServeProcess(t, "run", listenURI, false)
	defer stopServeProcess(t, cmd, logs)

	conn := dialServeAndWait(t, listenURI)
	defer conn.Close()

	requireUnaryEchoEventually(t, conn, "serve-unix")
	requireStreamEchoEventually(t, conn, []string{"serve-unix-stream-1", "serve-unix-stream-2"})
}

func TestRunServesGRPCOnWebSocket(t *testing.T) {
	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("ws://127.0.0.1:%d/grpc", port)

	cmd, logs := startServeProcess(t, "run", listenURI, false)
	defer stopServeProcess(t, cmd, logs)

	conn := dialServeWebSocketAndWait(t, listenURI)
	defer conn.Close()

	requireUnaryEchoEventually(t, conn, "serve-ws")
	requireStreamEchoEventually(t, conn, []string{"serve-ws-stream-1", "serve-ws-stream-2"})
}

func TestParseFlags(t *testing.T) {
	testCases := []struct {
		name string
		args []string
		want string
	}{
		{
			name: "listen-flag",
			args: []string{"--listen", "unix:///tmp/holon.sock"},
			want: "unix:///tmp/holon.sock",
		},
		{
			name: "legacy-port-flag",
			args: []string{"--port", "7070"},
			want: "tcp://:7070",
		},
		{
			name: "default",
			args: []string{"--unknown", "value"},
			want: "tcp://:9090",
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			if got := serve.ParseFlags(tc.args); got != tc.want {
				t.Fatalf("ParseFlags(%v) = %q, want %q", tc.args, got, tc.want)
			}
		})
	}
}

func TestRunWithOptionsReflectionToggle(t *testing.T) {
	testCases := []struct {
		name            string
		reflectEnabled  bool
		expectSupported bool
	}{
		{name: "reflection-enabled", reflectEnabled: true, expectSupported: true},
		{name: "reflection-disabled", reflectEnabled: false, expectSupported: false},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			port := freeTCPPort(t)
			listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
			address := fmt.Sprintf("127.0.0.1:%d", port)

			cmd, logs := startServeProcess(t, "run-with-options", listenURI, tc.reflectEnabled)
			defer stopServeProcess(t, cmd, logs)

			conn := dialServeAndWait(t, address)
			defer conn.Close()

			requireUnaryEchoEventually(t, conn, tc.name)
			requireReflectionState(t, conn, tc.expectSupported)
		})
	}
}

func TestRunGracefulShutdownOnContextCancellation(t *testing.T) {
	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
	address := fmt.Sprintf("127.0.0.1:%d", port)

	cmd, logs := startServeProcess(t, "run-with-options", listenURI, false)
	conn := dialServeAndWait(t, address)
	_ = conn.Close()

	ctx, cancel := context.WithCancel(context.Background())
	signalErr := make(chan error, 1)
	go func() {
		<-ctx.Done()
		signalErr <- cmd.Process.Signal(syscall.SIGTERM)
	}()

	cancel()
	if err := <-signalErr; err != nil {
		stopServeProcess(t, cmd, logs)
		t.Fatalf("signal serve helper: %v", err)
	}

	if err := waitProcessExit(cmd, 5*time.Second); err != nil {
		stopServeProcess(t, cmd, logs)
		t.Fatalf("serve helper did not exit gracefully: %v\nlogs:\n%s", err, logs.String())
	}

	ctxDial, cancelDial := context.WithTimeout(context.Background(), 400*time.Millisecond)
	defer cancelDial()
	postConn, err := grpcclient.Dial(ctxDial, address)
	if err == nil {
		defer postConn.Close()
		rpcCtx, rpcCancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
		defer rpcCancel()
		if _, rpcErr := unaryEcho(rpcCtx, postConn, "after-stop"); rpcErr == nil {
			t.Fatalf("expected RPC to fail after graceful shutdown")
		}
	}
}

func TestRunGracefulShutdownWithInFlightRPC(t *testing.T) {
	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
	address := fmt.Sprintf("127.0.0.1:%d", port)

	cmd, logs := startServeProcess(t, "run", listenURI, false)
	conn := dialServeAndWait(t, address)
	defer conn.Close()

	inFlightErrCh := make(chan error, 1)
	go func() {
		callCtx, callCancel := context.WithTimeout(context.Background(), 3*time.Second)
		defer callCancel()
		_, invokeErr := unaryEcho(callCtx, conn, "sleep-ms:1200")
		inFlightErrCh <- invokeErr
	}()

	time.Sleep(150 * time.Millisecond)
	if err := cmd.Process.Signal(syscall.SIGTERM); err != nil {
		stopServeProcess(t, cmd, logs)
		t.Fatalf("signal serve helper: %v", err)
	}
	if err := waitProcessExit(cmd, 5*time.Second); err != nil {
		stopServeProcess(t, cmd, logs)
		t.Fatalf("serve helper did not exit gracefully: %v\nlogs:\n%s", err, logs.String())
	}

	select {
	case invokeErr := <-inFlightErrCh:
		if invokeErr == nil {
			return
		}
		code := status.Code(invokeErr)
		if code == codes.Unavailable || code == codes.Canceled || code == codes.DeadlineExceeded {
			return
		}
		t.Fatalf("unexpected in-flight RPC error: %v", invokeErr)
	case <-time.After(3 * time.Second):
		t.Fatal("in-flight RPC did not finish during shutdown")
	}
}

func TestRunConcurrentClients(t *testing.T) {
	const clients = 10

	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
	address := fmt.Sprintf("127.0.0.1:%d", port)

	cmd, logs := startServeProcess(t, "run", listenURI, false)
	defer stopServeProcess(t, cmd, logs)

	conns := make([]*grpc.ClientConn, 0, clients)
	for i := 0; i < clients; i++ {
		conn := dialServeAndWait(t, address)
		conns = append(conns, conn)
	}
	defer func() {
		for _, conn := range conns {
			_ = conn.Close()
		}
	}()

	errCh := make(chan error, clients)
	var wg sync.WaitGroup
	wg.Add(clients)
	for i := 0; i < clients; i++ {
		i := i
		go func() {
			defer wg.Done()
			ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
			defer cancel()
			want := fmt.Sprintf("c-%d", i)
			got, err := unaryEcho(ctx, conns[i], want)
			if err != nil {
				errCh <- err
				return
			}
			if got != want {
				errCh <- fmt.Errorf("echo mismatch: got %q want %q", got, want)
			}
		}()
	}
	wg.Wait()
	close(errCh)

	for err := range errCh {
		if err != nil {
			t.Fatal(err)
		}
	}
}

func TestRunMetadataHeadersAndTrailers(t *testing.T) {
	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
	address := fmt.Sprintf("127.0.0.1:%d", port)

	cmd, logs := startServeProcess(t, "run", listenURI, false)
	defer stopServeProcess(t, cmd, logs)

	conn := dialServeAndWait(t, address)
	defer conn.Close()

	client := testgrpc.NewTestServiceClient(conn)
	var header metadata.MD
	var trailer metadata.MD

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()
	_, err := client.UnaryCall(
		ctx,
		&testgrpc.SimpleRequest{
			Payload: &testgrpc.Payload{
				Type: testgrpc.PayloadType_COMPRESSABLE,
				Body: []byte("metadata-probe"),
			},
		},
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	if err != nil {
		t.Fatalf("unary metadata call: %v", err)
	}

	if got := header.Get("x-holon"); len(got) == 0 || got[0] != "go-holons" {
		t.Fatalf("header x-holon = %v, want [go-holons]", got)
	}
	if got := trailer.Get("x-holon-trailer"); len(got) == 0 || got[0] != "done" {
		t.Fatalf("trailer x-holon-trailer = %v, want [done]", got)
	}
}

func TestRunRejectsOversizedMessage(t *testing.T) {
	port := freeTCPPort(t)
	listenURI := fmt.Sprintf("tcp://127.0.0.1:%d", port)
	address := fmt.Sprintf("127.0.0.1:%d", port)

	cmd, logs := startServeProcess(t, "run", listenURI, false)
	defer stopServeProcess(t, cmd, logs)

	conn := dialServeAndWait(t, address)
	defer conn.Close()

	client := testgrpc.NewTestServiceClient(conn)
	oversized := bytes.Repeat([]byte("a"), 5*1024*1024)

	ctx, cancel := context.WithTimeout(context.Background(), 4*time.Second)
	defer cancel()
	_, err := client.UnaryCall(ctx, &testgrpc.SimpleRequest{
		Payload: &testgrpc.Payload{
			Type: testgrpc.PayloadType_COMPRESSABLE,
			Body: oversized,
		},
	})
	if status.Code(err) != codes.ResourceExhausted {
		t.Fatalf("expected RESOURCE_EXHAUSTED, got %v (%v)", status.Code(err), err)
	}

	requireUnaryEchoEventually(t, conn, "post-oversize")
}

func startServeProcess(t *testing.T, mode, listenURI string, reflectEnabled bool) (*exec.Cmd, *bytes.Buffer) {
	t.Helper()

	cmd := exec.Command(os.Args[0], "-test.run=TestServeHelperProcess", "--", mode, listenURI, strconv.FormatBool(reflectEnabled))
	cmd.Env = append(os.Environ(), "GO_WANT_SERVE_HELPER=1")

	var logs bytes.Buffer
	cmd.Stdout = &logs
	cmd.Stderr = &logs

	if err := cmd.Start(); err != nil {
		t.Fatalf("start serve helper: %v", err)
	}

	return cmd, &logs
}

func stopServeProcess(t *testing.T, cmd *exec.Cmd, logs *bytes.Buffer) {
	t.Helper()

	if cmd == nil || cmd.Process == nil {
		return
	}

	_ = cmd.Process.Signal(syscall.SIGTERM)
	if err := waitProcessExit(cmd, 4*time.Second); err != nil {
		_ = cmd.Process.Kill()
		_ = cmd.Wait()
		t.Fatalf("stop serve helper: %v\nlogs:\n%s", err, logs.String())
	}
}

func waitProcessExit(cmd *exec.Cmd, timeout time.Duration) error {
	waitCh := make(chan error, 1)
	go func() {
		waitCh <- cmd.Wait()
	}()

	select {
	case err := <-waitCh:
		if err != nil {
			var exitErr *exec.ExitError
			if errors.As(err, &exitErr) {
				return fmt.Errorf("process exited with status %d", exitErr.ExitCode())
			}
			return err
		}
		return nil
	case <-time.After(timeout):
		return fmt.Errorf("timeout waiting for process exit")
	}
}

func helperProcessArgs(args []string) []string {
	for i, arg := range args {
		if arg == "--" {
			if i+1 < len(args) {
				return args[i+1:]
			}
			return nil
		}
	}
	return nil
}

func freeTCPPort(t *testing.T) int {
	t.Helper()

	lis, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("allocate free port: %v", err)
	}
	defer lis.Close()

	addr, ok := lis.Addr().(*net.TCPAddr)
	if !ok {
		t.Fatalf("unexpected listener addr type: %T", lis.Addr())
	}
	return addr.Port
}

func dialServeAndWait(t *testing.T, address string) *grpc.ClientConn {
	t.Helper()

	deadline := time.Now().Add(6 * time.Second)
	var lastErr error

	for time.Now().Before(deadline) {
		ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
		conn, err := grpcclient.Dial(ctx, address)
		cancel()
		if err == nil {
			rpcCtx, rpcCancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
			_, rpcErr := unaryEcho(rpcCtx, conn, "probe")
			rpcCancel()
			if rpcErr == nil {
				return conn
			}
			lastErr = rpcErr
			_ = conn.Close()
		} else {
			lastErr = err
		}
		time.Sleep(40 * time.Millisecond)
	}

	t.Fatalf("server %s not ready: %v", address, lastErr)
	return nil
}

func requireReflectionState(t *testing.T, conn *grpc.ClientConn, enabled bool) {
	t.Helper()

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	client := reflectionv1alpha.NewServerReflectionClient(conn)
	stream, err := client.ServerReflectionInfo(ctx)
	if err != nil {
		if !enabled && status.Code(err) == codes.Unimplemented {
			return
		}
		t.Fatalf("reflection stream: %v", err)
	}

	req := &reflectionv1alpha.ServerReflectionRequest{
		MessageRequest: &reflectionv1alpha.ServerReflectionRequest_ListServices{ListServices: "*"},
	}
	if err := stream.Send(req); err != nil {
		if !enabled && status.Code(err) == codes.Unimplemented {
			return
		}
		t.Fatalf("reflection send: %v", err)
	}

	resp, err := stream.Recv()
	if !enabled {
		if status.Code(err) == codes.Unimplemented {
			return
		}
		t.Fatalf("expected reflection to be disabled, got response=%v err=%v", resp, err)
	}
	if err != nil {
		t.Fatalf("reflection recv: %v", err)
	}

	services := resp.GetListServicesResponse().GetService()
	for _, svc := range services {
		if svc.GetName() == "grpc.testing.TestService" {
			return
		}
	}
	t.Fatalf("reflection response missing grpc.testing.TestService")
}

func requireUnaryEchoEventually(t *testing.T, conn *grpc.ClientConn, msg string) {
	t.Helper()

	deadline := time.Now().Add(3 * time.Second)
	var lastErr error

	for time.Now().Before(deadline) {
		ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
		out, err := unaryEcho(ctx, conn, msg)
		cancel()
		if err == nil {
			if out != msg {
				t.Fatalf("echo mismatch: got %q want %q", out, msg)
			}
			return
		}
		lastErr = err
		time.Sleep(30 * time.Millisecond)
	}

	t.Fatalf("echo RPC did not succeed before deadline: %v", lastErr)
}

func unaryEcho(ctx context.Context, conn *grpc.ClientConn, msg string) (string, error) {
	client := testgrpc.NewTestServiceClient(conn)
	resp, err := client.UnaryCall(ctx, &testgrpc.SimpleRequest{
		Payload: &testgrpc.Payload{
			Type: testgrpc.PayloadType_COMPRESSABLE,
			Body: []byte(msg),
		},
	})
	if err != nil {
		return "", err
	}
	return string(resp.GetPayload().GetBody()), nil
}

func requireStreamEchoEventually(t *testing.T, conn *grpc.ClientConn, messages []string) {
	t.Helper()

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	client := testgrpc.NewTestServiceClient(conn)
	stream, err := client.FullDuplexCall(ctx)
	if err != nil {
		t.Fatalf("full duplex call: %v", err)
	}

	for _, msg := range messages {
		if err := stream.Send(&testgrpc.StreamingOutputCallRequest{
			Payload: &testgrpc.Payload{
				Type: testgrpc.PayloadType_COMPRESSABLE,
				Body: []byte(msg),
			},
		}); err != nil {
			t.Fatalf("stream send %q: %v", msg, err)
		}
		resp, err := stream.Recv()
		if err != nil {
			t.Fatalf("stream recv %q: %v", msg, err)
		}
		if got := string(resp.GetPayload().GetBody()); got != msg {
			t.Fatalf("stream echo mismatch: got %q want %q", got, msg)
		}
	}
	if err := stream.CloseSend(); err != nil {
		t.Fatalf("stream close send: %v", err)
	}
}

func dialServeWebSocketAndWait(t *testing.T, wsURI string) *grpc.ClientConn {
	t.Helper()

	deadline := time.Now().Add(6 * time.Second)
	var lastErr error
	for time.Now().Before(deadline) {
		ctx, cancel := context.WithTimeout(context.Background(), 600*time.Millisecond)
		conn, err := grpcclient.DialWebSocket(ctx, wsURI)
		cancel()
		if err == nil {
			return conn
		}
		lastErr = err
		time.Sleep(50 * time.Millisecond)
	}
	t.Fatalf("websocket server %s not ready: %v", wsURI, lastErr)
	return nil
}

func parseSleepMillis(payload []byte) time.Duration {
	const prefix = "sleep-ms:"
	if !strings.HasPrefix(string(payload), prefix) {
		return 0
	}
	millis, err := strconv.Atoi(strings.TrimPrefix(string(payload), prefix))
	if err != nil || millis <= 0 {
		return 0
	}
	return time.Duration(millis) * time.Millisecond
}
